1. 쿠키와 세션의 차이에 대해 설명해주세요.
**쿠키**는 클라이언트에 저장되는 key-value 형태의 작은 데이터 파일이다. 웹 사이트 재방문 시 효율적으로 서비스를 제공하기 위해 사용한다.
특징
- 브라우저 단위로 생성
- 다른 도메인을 대신하여 쿠키 발급 불가
- 만료 시간까지 상태 정보 유지
쿠키 탈취 시 쿠키의 값을 임의로 바꿀 수 있고 대신 로그인 할 수 있다.
**세션**은 웹 사이트에 이용되는 사용자 정보를 서버에 저장하는 방법이다. 쿠키 + 세션 사용 시, 쿠키에 sessionId 외의 정보를 기록하지 않음으로써 안전성을 확보한다.
단점
- 유저 정보가 서버에 있기 때문에 처리 속도에 대한 비용이 발생한다.
- 서버 자원을 사용하기 때문에 유저가 많아지면 저장 공간에 대한 비용 발생
2. HTTP 응답코드에 대해 설명해 주세요.
**1xx(정보)**, 요청을 받았으며 프로세스를 계속 처리 중이다.
**2xx(성공)**, 요청을 성공적으로 처리했다.
- 200 OK 요청을 성공했다.
- 201 Created 요청 성공해서 새로운 리소스가 생성되었다. 주로 POST, PUT 요청 이후에 따라온다.
- 202 Accepted, 요청을 수신했지만 아직 처리가 완료되지 않았다. 예를 들어, 요청 접수 후에 서버에서 1시간 뒤에 배치 프로세스가 요청을 처리한다.
- 204 No Content, 요청을 성공했지만 응답 페이로드 본문에 보낼 데이터가 없다.
**3xx(리다이렉션)**, 요청 완료를 위해 웹 브라우저에서 추가 작업 조치가 필요하다. 웹 브라우저는 3xx 응답의 결과에 Location 헤더가 있으면 Location 위치로 자동 이동한다. 
- 영구적인 리다이렉션, 특정 리소스의 URI가 영구적으로 이동한다. 301(Moved Permanently), 308(Permanent Redirect)
- 일시적인 리다이렉션, 일시적인 변경이다. 302(Found), 303(See Other), 307(Temporary Redirect)
- 특수한 리다이렉션, 결과 대신 캐시를 사용한다. 304(Not Modified)
**4xx(클라이언트 오류)**, 요청의 문법이 잘못되었거나 요청을 처리할 수 없다.
- 400(Bad Request), 잘못된 문법이나 메시지를 요청해서 서버가 이해할 수 없다.
- 401(Unauthorization), 클라이언트가 해당 리소스에 대한 인증이 필요하다. 예를 들어 로그인이다.
- 403(Forbidden), 서버가 요청을 이해했지만 승인을 거부했다. 인증, 즉 로그인은 되었지만
접근이 불충한 경우이다.
- 404(Not Found), 요청 리소스를 찾을 수 없다.
**5xx(서버 오류)**, 서버가 정상 요청을 처리하지 못했다.
- 500(Internal Server Error), 서버 내부 문제로 오류가 발생했다.
- 502(Bad Gateway), 서버 간 유효하지 않은 응답을 받았다.
- 503(Service Unavaliable), 서버가 일시적으로 요청을 처리할 준비가 되지 않았다. 유지보수를 위한 작동이 중단되거나 과부하가 걸렸다.
3. HTTP Method 에 대해 설명해 주세요.
GET, 리소스를 조회한다.
POST, 요청 데이터를 처리하며 주로 등록에 사용된다. 헤더에 신규 리소스 주소인 Location이 포함된다.
PUT, 리소스를 완전히 대체하고 해당 리소스가 없으면 생성한다.
PATCH, 리소스를 부분 변경한다.
DELETE, 리소스를 삭제한다.
HEAD, 데이터는 받지 않고 Header만 받는다.

HTTP 메서드는 3가지 속성이 있다. 
- 안전한 메서드(Safe Methods)
메서드를 호출해도 리소스를 변경하지 않는다는 특성이다. 즉, 서버에 데이터를 변경하지 않는 요청 메서드로 GET이 해당된다.
- 멱등성(Idempotent Methods)
연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질을 말한다.
GET은 멱등이고 안전한다.
PUT, DELETE는 멱등이지만 안전하지 않다.
POST, PATCH는 멱등이지도 안전하지도 않다.
참고로 PATCH는 멱등으로 설계할 수도 멱등이 아니게 설계할 수도 있다. PATCH 요청할 때마다 like를 1씩 더하는 메서드를 설계한다면 멱등이 아니다.
- 캐싱 가능(Cacheable Methods)
응답 결과를 서버에 캐싱해서 사용해도 되는 메서드를 의미한다. 캐싱을 해서 데이터를 효율적으로 가져올 수 있다. GET, HEAD, POST, PATCH가 가능하지만 일반적으로 GET, HEAD 정도만 캐싱한다.
4. HTTP에 대해 설명해 주세요.
Hypertext Protocol, 서버 - 클라이언트 간의 메시지 교환 프로토콜이다.
Request 구조
![Request](https://github.com/heenahan/tech-interview/assets/83766322/17a968fd-9103-4ed0-ac0e-22ace49a7c77)
- start line 
메서드, URI, 프로토콜 버전
- headers
- 공백 라인
- 바디
Response 구조
![Response](https://github.com/heenahan/tech-interview/assets/83766322/b4a36997-144f-440a-808c-2695cb4489f4)
- status line
프로토콜 버전, 상태 코드, 상태 코드 설명
- headers
- 공백 라인
- 바디
HTTP의 특징은 
- Stateless 상태 없음
과거 정보를 남기지 않고 새로운 Request를 보낼 때마다 새로운 Response를 보낸다. 상태와 무관하니 확장이 쉽다.
- URI로 리소스를 식별
Request에서 URI로 리소스를 식별한다.
- 지속 연결
초기 HTTP는 비지속 연결을 사용했다. 요청을 주고 받을 때마다 새로운 TCP 커넥션을 연결하고 종료했다.
주고 받을 데이터가 많아지면서 매번 TCP 연결과 종료를 하니 자원 낭비가 있고 속도가 느려졌다. 그래서 지속 연결을 통해 통신을 좀 더 빠르게 했다. 
5. 웹소켓과 소켓 통신의 차이에 대해 설명해 주세요.
**소켓**은 OS 커널에 구현되어 있는 프로토콜 요소에 대한 **추상화된 인터페이스**이다. 장치 파일의 일종으로 일반 파일에 대한 개념이 대부분 적용된다. 소켓은 파일이라고 생각해야 한다.
소켓 프로그래밍은 TCP 소켓을 이야기하며 TCP 대상을 추상화시킨 파일에 대한 입출력 방법론이다. 주체인 Process가 TCP 소켓을 Open, Create, Close, Delete가 가능한데 Write는 송신,  Read는 수신한다고 한다.
**웹소켓**은 소켓처럼 IP, Port 통신을 한다. 웹 브라우저는 HTTP 프로토콜을 사용하는데 요청을 보내면 응답이 오는 단방향적 구조로 통신한다. 그렇기 때문에 TCP/IP 프로토콜을 사용하는 소켓처럼 계속 connection이 유지되는 실시간 통신을 할 수 없다. 이런 실시간 통신의 문제점을 해결하기 위해 웹소켓 프로토콜이 등장했다. 웹 소켓을 사용하면 웹 브라우저에서도 소켓 통신을 하는 것처럼 실시간으로 데이터를 주고받을 수 있다.
6. HTTP/1.1과 HTTP/2의 차이점은 무엇인가요?
**HTTP/1.1**는 하나의 TCP 연결을 재사용해 많은 콘텐츠를 제공할 수 있는 지속적 연결 기술(keep alive)가 추가되었다.
HTTP1.1의 또 다른 특징 중 하나는 파이프라이닝 기술이다. 파이프라이닝은 브라우저가 웹 서버에 여러 개의 콘텐츠를 요청했을 때, 이전 요청에 대한 응답을 완전하게 받지 않더라도 하나의 connection 내에서 미리 다음 요청을 전달하면서 전체적인 전달 시간을 줄인다.
![HTTP/1.1](https://github.com/heenahan/tech-interview/assets/83766322/2c4e054a-863a-4105-8c90-181925800097)
HTTP/1.1은 단점은 다음과 같다.
- HOL(Head Of Line) Blocking 
특정 응답의 지연이 발생한다. Connection을 통해서 다수개의 파일을 요청받을 때 첫번째 요청의 응답이 지연되면 뒤의 요청의 응답이 함께 지연된다.
- 무거운 Header 구조
HTTP/1.1의 헤더에는 많은 메타정보를 저장한다. 매 요청마다 중복된 Header 값을 전송하게 된다.
**HTTP/2**는 이러한 HTTP/1.1의 단점을 여러가지 방법으로 극복했다.
- Binary Framing
HTTP/1.1에서 text 형식으로 전달되던 요청, 응답 메시지를 **프레임 단위**로 나누고 바이너리 형식으로 인코딩했다. 바이너리는 컴퓨터가 더 이해하기 쉬워 파싱, 전송 속도가 빨라진다.
- Multiplex Streaming
TCP 연결한 뒤 스트림을 생성할 수 있다. 스트림은 파이프와 다르게 양방향 데이터 흐름이 가능하고 각 스트림에는 고유 식별자와 우선순위 정보가 있다. 
HTTP 메시지는 하나 이상의 프레임으로 구성되는데, 프레임을 전달받은 쪽에서 프레임의 헤더에 있는 스트림 식별자를 통해 재조립하여 요청과 응답 메시지를 확인할 수 있다.
- 헤더 압축 
HPACK 압축 형식을 사용하여 요청 및 응답 헤더 메타데이터를 압축한다.
- Server Push
클라이언트가 요청한 리소스에 연관된 다른 리소스들을 함께 push할 수 있다. 이를 통해 클라이언트의 요청을 최소화하여 성능을 향상시킨다.
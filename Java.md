## 1. 접근 제어자들의 차이점
- private, 클래스 내부에서만 접근 가능하다.
- default, 같은 패키지 내의 클래스만 접근 가능하다.
- protected, 동일한 패키지에 속한 클래스들과 해당 클래스를 상속받은 클래스들만 접근 가능하다.
- public, 모든 클래스에서 접근 가능하다.

접근 제어자를 적절하게 설정하여 클래스의 구현 세부 사항을 숨긴다(캡슐화). 또한 접근 제어자로 다른 개발자들에게 의도를 전달할 수 있다. 

## 2. 인터페이스와 추상클래스의 차이 
먼저 공통점으로 둘 다 인스턴스화할 수 없다.

인터페이스는 모든 메서드가 추상 메서드로만 구성되어 있다. 인터페이스는 구현 객체가 같은 동작을 보장하도록 하기 위해 사용되므로 구현 클래스에서 이를 구현해야 한다. 

반면 추상 클래스는 추상 메서드와 일반 메서드를 모두 포함할 수 있으며, 일부 기능을 구현함으로써 자식 클래스의 개발을 용이하게 한다. 추상 클래스는 공통적인 기능을 미리 구현해 두어 상속받는 클래스에서 이를 재사용할 수 있게 한다. 이는 코드의 중복을 줄이고 유지보수를 용이하게 하는 데 도움이 된다.

자바에서 클래스는 다중 상속을 지원하지 않는다. 같은 메서드 시그니처를 가지는 두 부모를 상속받을 때 둘 중 어떤 메서드를 상속받아야 하는지 모호해지기 때문이다. 반면 인터페이스는 다중 상속을 지원하며, 동일한 인터페이스는 주로 다중 상속을 필요로 하는 상황에서 사용한다. 예를 들어 인터페이스를 구현함으로써 한 클래스가 다양한 역할을 수행할 수 있게 한다.

## 3. 원시값 포장과 VO 차이
VO(Value Object)는 값 나타내는 객체이다. 예르를 들어 자바에서 제공하는 String은 이에 해당된다. String은 char 배열을 감싸는 객체로, 불변성과 동등성을 보장한다.

원시값 포장은 원시값을 감싸는 것을 의미한다. VO와 유사하지만 원시값만을 감싸며 불변성과 동등성을 보장할 필요는 없다. 

둘은 값의 생성, 유효성 검사 및 관련 로직을 객체 내부로 캡슐화하여 책임을 하나의 객체에 모을 수 있다.

## 4. static과 non-static의 차이
static은 클래스가 로딩될 때 초기화되고 non-static은 객체를 생성할 때, 인스턴스화될 때 초기화된다.

static은 인스턴스화가 필요없는 유틸 클래스 혹은 상수에 붙인다.

## 6. 일급 컬렉션이 무엇이고 왜 사용하는지?
Collection을 Wrapping하면서 다른 멤버 변수가 없는 클래스를 말한다.

일급 컬렉션을 통해 비즈니스에 종속적인 자료구조를 만들 수 있다. 컬렉션의 불변성을 보장하고 상태와 행위를 한 곳에서 관리할 수 있으며 컬렉션에 이름을 붙일 수 있다.

### 💫 컬렉션의 불변성을 어떻게 보장?
Collectors의 toUnmodifiableList()를 반환해서 변경 불가능한 리스트로 반환한다.

## 8. string pool을 사용하는 이유
String 리터럴로 생성한 객체는 Heap 영역 내 String Constant Pool에 저장되어 재사용된다. 즉, 내용이 같다면 동일한 메모리 주소를 참조한다.

반면 new 키워드를 사용해 생성한 String 객체는 같은 내용이더라도 여러 개의 객체가 각각 Heap 영역을 차지하게 된다.

메모리를 효율적으로 사용하기 위해서는 String literal로 String을 생성하여 String pool을 사용하는 것이 좋다.

https://openjdk.org/jeps/122

## 10. equals와 hashCode를 사용하는 이유
모든 클래스는 Object 클래스를 상속받는다. Objcet 클래스에 equals와 hasCode, toString 등의 메서드가 포함되있다. 이 메서드들은 객체를 관리하고 비교하는 데 필수적인 역할을 한다.

equals 메서드는 두 객체의 동등성을 비교하는 데 사용된다. hashCode 메서드는 객체의 해시 코드 값을 반환하는데 사용되며 해시 기반의 자료구조에서 중요한 역할을 한다.

equals와 hashCode는 같이 재정의해야 한다. has값을 사용하는 Collection(HashMap, HashSet, HashTable)은 객체가 논리적으로 같은지 비교할 때 아래 그림과 같은 과정을 거치기 때문이다.
![equals and hashcode](https://github.com/heenahan/tech-interview/assets/83766322/af9d5da1-91f7-43c2-bf25-d250323c5b0a)

hashCode 메서드의 리턴 값이 우선 일치하고 equals 메서드의 리턴 값이 true여야 논리적으로 같은 객체라고 판단한다.

## 16. Enum의 장단점
Enum은 다양한 장점이 있다.
- 코드 가독성 향상
    - 관련된 상수를 논리적으로 그룹화하여 코드를 이해하기 쉽게 만들고, 가독성을 향상시킨다.
- 타입 안정성(Type Safety)
    - 열거형은 컴파일러가 타입을 검사할 수 있도록 하여 오류를 줄일 수 있다.
- 스레드 안전성(Thread Safety)
    - 열거형은 JVM에 의해 싱글톤 패턴으로 구현되어 있어 멀티스레드 환경에서 안전하게 사용할 수 있다.
Enum은 반대로 단점도 있다.
- 상수 개수 제한
    - 열거형은 미리 정의된 상수 집합을 사용하므로, 동적으로 상수를 추가할 수 없다.
- 메모리 사용량 증가
    - 열거형은 클래스로 컴파일되기 때문에 일반적인 상수와 비교하여 메모리 사용량이 더 많다.
- 유연성 감소
    - 열거형은 상속을 지원하지 않는다. 따라서 열거형을 상속하거나 인터페이스를 구현하는 것은 불가능해서 유연성이 제한된다.

## 18. final 키워드에 대해 설명
자바에서 final 키워드는 변수, 메서드, 클래스에 사용할 수 있다.

변수에 final 키워드를 붙이면 값이 한 번만 할당될 수 있음을 의미한다. 즉, 한 번 초기화된 값은 변경되지 않는다.
단 primitive type이 아닌 객체의 경우 완전한 불변을 보장하지 않는다. 

메서드에 final 키워드를 붙이면 메서드가 하위 클래스에서 오버라이드될 수 없다.

클래스에 final 키워드를 붙이면 해당 클래스가 다른 클래스에 의해 상속될 수 없다.

### 객체의 경우 완전한 불변을 어떻게 보장? 
Java에서 final은 정확하게 불변을 만들어주는 것은 아니고 재할당을 금지한다. 따라서 객체를 불변으로 보장하고 싶다면 불변 타입의 멤버 변수를 모두 final로 선언한다.

## 20. Java Stream API란
Java Stream API는 Java 8에서 소개된 기능으로 컬렉션 요소를 처리하는데 사용된다. Stream API는 함수형 프로그래밍을 지원하며 코드를 간결하게 작성할 수 있도록 도와준다.

내부 반복으로 데이터를 처리하며 중간 연산이 실제로 처리되는 시점은 최종 연산이다(게으른 연산).

순차 혹은 병렬 처리를 할 수 있다. 병렬 처리를 위해 멀티스레드를 활용하며, parallet() 메서드를 사용하여 스트림을 병렬 스트림으로 변환할 수 있다.

### 게으른 연산이란 (스트림의 동작 과정)
결과가 필요할 때까지 계산은 늦춘다. 중간 연산은 호출 즉시 실행되지 않고 파이프라인을 구성할 뿐이다. 이 파이프라인들은 최종 연산이 호출됐을 때 한 번에 동작하게 된다.

결과가 필요할 때까지 계산을 늦춤으로써 실행을 최적화할 수 있다. JVM은 계산을 실행하기 전에 스트림 파이프라인이 어떤 중간 연산과 최종 연산으로 구성되었는지 파악한 뒤 어떤 방식으로 최적화를 진행할지 미리 계획하고 연산을 수행한다. 

스트림의 최적화 전략 
1. 루프 퓨전
2. 쇼트 서킷

https://velog.io/@qwerty1434/%EC%8A%A4%ED%8A%B8%EB%A6%BC%EC%9D%98-%EA%B2%8C%EC%9C%BC%EB%A6%84

### Fork Join Pool이란? 스레드 풀과 차이
Java 7에서 지원하는 fork-join 풀은 기본적으로 큰 업무를 작은 업무로 배분하여 일을 한 후에 일을 취합하는 형태이다.

하나의 작업 큐를 가지고 있으며 Fork Join Pool에서 

## 21. 익명 함수와 람다 표현식
익명 함수는 이름이 없는 함수로 Java에서 익명 함수를 구현하기 위해 익명 내부 클래스를 사용한다. 익명 클래스는 인터페이스를 구현하는 동시에 다른 클래스를 상속받을 수 없으며 여러 인터페이스를 구현할 수 없다. 또한, 익명 클래스가 길어지는 경우에 가독성이 떨어진다,

람다 표현식은 Java 8에서 등장하였고 함수형 인터페이스의 인스턴스를 람다식을 사용해 만들 수 있다. 람다식은 간결한 문법을 이용하여 가독성 좋은 코드를 작성할 수 있다.

## 24. 함수형 인터페이스란
딱 하나의 추상메서드를 가지고 있는 인터페이스를 뜻한다. 람다 표현식이나 메서드 참조와 같은 함수형 프로그래밍의 스타일을 지원하기 위해 사용된다.

## 26. 제네릭이란
Java Generic은 타입 안전성을 제공하고 재사용성을 높이기 위한 기능으로 컬렉션 클래스나 메서드 등에서 다양한 타입을 사용할 수 있도록 도와준다.

- 타입 안정성
    - 컴파일 시점에 타입 안전성을 보장
- 코드 재사용성 증가
    - 여러 종류의 객체에 대해 동일한 코드 작성
- 유연성 제공
    - 다양한 타입의 객체를 다룰 수 있으므로 보다 유연한 코드 작성

## 27. JVM이란
![JVM](https://github.com/heenahan/tech-interview/assets/83766322/1bac6607-f6cf-4d5c-a965-3b2ceb3621c9)

자바 가상 머신으로 자바 바이트 코드(.class 파일)를 OS에 특화된 코드로 변환(인터프리터와 JIT 컴파일러)하여 실행한다.

- 클래스 로더
   - .class 에서 바이트코드를 읽고 메모리에 저장
   - 로딩: 클래스 읽어오는 과정
   - 링크: 레퍼런스를 연결하는 과정
   - 초기화: static 값들 초기화 및 변수에 할당
- 메모리
    - 메서드 영역
        - 클래스 수준의 정보 (클래스 이름, 부모 클래스 이름, 메소드, 변수) 저장. 
        - 공유 자원이다.
        - 내부에 Runtime Constant Pool이 위치하고 이것은 String Pool가 다르다. String Pool은 Heap에 위치해있다.
    - 힙 영역 
        - 객체를 저장. 
        - 공유 자원으로 GC의 대상
    - 스택 영역
        - 메서드 호출 시 지역 변수, 매개변수, 함수 호출내역 등이 저장되는 영역
        - 쓰레드마다 런타임 스택을 만들고,그 안에 메소드 호출을 스택 프레임이라 부르는 블럭으로 쌓는다. 
        - 쓰레드 종료하면 런타임 스택도 사라진다.
    - PC(Program Counter) 레지스터
        - 쓰레드 마다 쓰레드 내 현재 실행할 스택 프레임을 가리키는 포인터가 생성된다.
    - 네이티브 메소드 스택 
        - Java가 아닌 다른 언어(C/C++ 등)으로 실행된 메서드를 호출할 때마다 생성되었다가 호출이 완료되면 사라짐
- 실행 엔진
   - 인터프리터: 바이크 코드를 한줄 씩 실행.
   - JIT 컴파일러: 인터프리터 효율을 높이기 위해, 인터프리터가 반복되는 코드를 발견하면 JIT 컴파일러로 반복되는 코드를 모두 네이티브 코드로 바꿔둔다. 그 다음부터 인터프리터는 네이티브 코드로 컴파일된 코드를 바로 사용한다.
   - GC(Garbage Collector): 더이상 참조되지 않는 객체를 모아서 정리한다.
### Java 8이후의 메모리 영역은 어떻게 달라졌나요
![JVM jdk8](https://github.com/heenahan/tech-interview/assets/83766322/eafa20c3-b4d7-4c0c-9e3b-bb2d546876d4)

메소드 영역은 JVM 벤더마다 다양한 형태로 구현할 수 있으며, 오라클 핫스팟 JVM에서는 흔히 PermGen = Permanent Generation(자바 1.7 이전), MetaSpace(자바 1.8 이후)로 부른다.
        
Permanent Generation은 메모리가 부족할 시에는 OutOfMemory 문제가 발생할 수 있다. 실제로 java 진영에서 알아본 결과, Heap 영역의 크기는 한정되어 있고 Permanent Generation 영역은 클래스 로딩과 언로딩, 리플렉션, 프록시 등의 기능을 사용할 때 메모리 누수와 OutOfMemory의 원인이 되는 경우가 많았다.

하지만 Metaspace 를 Heap 영역에서 분리함으로써, OutOfMemory문제를 조금 덜 만날 수 있게 되었다. 기본적으로 JVM의 Heap 영역은 OS에 의해 관리되는 메모리(Native Memory)의 크기에 비해 작기 때문이다.

출처 : https://velog.io/@ddangle/Java-%EB%9F%B0%ED%83%80%EC%9E%84-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%98%81%EC%97%ADRuntime-Data-Area%EC%97%90-%EB%8C%80%ED%95%B4
## 27. 가비지 컬렉션이란
가비지 컬렉션(Garbage Collection, GC)은 더 이상 사용되지 않는 메모리를 자동으로 찾아 해제하는 프로세스이다. 개발자가 직접 메모리를 관리해야 하는 부담을 줄여주고, 메모리 누수(memory leak)와 같은 문제를 방지하는데 도움을 준다.

가비지 컬렉션도 단점이 있다. 메모리가 언제 해제되는지 정확하게 알 수 없어 제어하기 어렵다. 가비지 컬렉션(GC)이 동작하는 동안에는 다른 동작을 멈추기 때문에 오버헤드가 발생한다. 이를 Stop-The-World라 한다.

가비지 컬렉션이 동작하는 과정은 다음과 같다.
1. Mark And Sweep
가비지 컬렉션이 될 대상 객체를 식별(Mark)하고 제거(Sweep)한다. 좀 더 구체적으로 말하면, Root Space로부터 그래프 순회를 통해 연결된 객체를 찾아내어 각각 어떤 객체를 참조하고 있는지 찾아서 마킹한다. 그리고 참조되지 않은 객체 즉 Unreachable 객체들을 Heap에서 제거한다.
2. Compact
체가 제거되어 파편화된 메모리 영역을 앞에서부터 채워나가는 작업(Compaction)을 수행하게 된다. 가비지 컬렉션에 따라 하지 않기도 한다.

Heap 영역은 Young Generation과 Old Generation으로 구분된다. Young 영역은 더욱 효율적인 GC를 위해 Eden, survivor0, suervivor1 3가지 영역으로 나눈다.
- Young Gen
    - 대부분의 객체가 금방 Unreachable 상태가 되기 때문에, 많은 객체가 Young 영역에 생성되었다가 사라진다.
    - Young 영역에 대한 가비지 컬렉션(Garbage Collection)을 Minor GC라고 부른다.
- Eden 
    - new를 통해 새로 생성된 객체가 위치한다. 
    - 정기적인 쓰레기 수집 후 살아남은 객체들은 Survivor 영역으로 보낸다.
- survivor0 / survivor1
    - 최소 1번의 GC 이상 살아남은 객체가 존재하는 영역
    - Survivor 영역에는 특별한 규칙이 있는데, Survivor 0 또는 Survivor 1 둘 중 하나에는 꼭 비어 있어야 하는 것이다.
- Old Gen
    - Young 영역보다 크게 할당되며, 영역의 크기가 큰 만큼 가비지는 적게 발생한다.
    - Old 영역에 대한 가비지 컬렉션(Garbage Collection)을 Major GC 또는 Full GC라고 부른다.

사실 위 과정은 Serial GC의 동작 과정으로 더 발전된 GC는 다르게 수행한다.

### GC 종류
## 28. 오버로딩과 오버라이딩의 차이
오버로딩은 메서드 이름은 같지만 메서드 시그니처(파라미터 타입, 개수, 순서)가 다르면 다르다고 판단한다.

오버라이딩은 상위 클래스의 메서드를 하위 클래스에서 다시 정의하는 것이다.
## 37. Sealed 클래스란
Java 17부터 도입된 Sealed 클래스는 한정된 하위 클래스를 갖도록 클래스를 정의하는 방법이다.
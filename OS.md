## 1. 시스템 콜이 무엇인지 설명해 주세요.
1. 프로그램 실행 중에 인터럽트(interrupt)가 발생하거나 시스템 콜(System call)을 호출하게 되면 유저모드에서 커널모드로 전환된다.
2. 커널모드로 전환되면 프로그램의 현재 CPU 상태를 저장한다. 그리고 커널이 인터럽트나 시스템 콜을 직접 처리한다. 즉, CPU에서 커널 코드가 실행된다.
3. 처리가 완료되면 중단됐던 프로그램의 CPU 상태를 복원한다.
4. 다시 통제권을 프로그램에게 반환하며 커널모드에서 유저모드로 전환된다.
5. 유저모드에서 프로그램이 이어서 실행된다.
커널은 운영체제의 핵심으로 시스템의 전반을 관리/감독하며 하드웨어와 관련된 작업을 직접 수행한다. 
시스템을 보호하기 위해 커널모드가 존재한다. 즉, 프로그램이 함부로 하드웨어를 점유해서 시스템을 붕괴시키지 못하도록 커널모드가 존재한다. 
**시스템 콜**은 프로그램이 OS 커널이 제공하는 서비스를 이용하고 싶을 때 시스템 콜을 통해 실행한다.
프로세스/스레드 관련, 파일 I/O 관련, 소켓 관련, 장치(device) 관련, 프로세스 통신 관련한 시스템 콜이 있디/ 
## 2. 인터럽트가 무엇인지 설명해 주세요.
**인터럽트**는 시스템에서 발생한 다양한 종류의 이벤트 혹은 그런 이벤트를 알리는 메커니즘이다.
전원에 문제가 생겼을 때, I/O 작업이 완료되었을 때, 시간이 다 됐을때, 0으로 나눴을 때, 잘못된 메모리 공간에 접근을 시도할 때 인터럽트가 발생한다.
인터럽트가 발생하면 CPU에서는 즉각적으로 인터럽트 처리를 위해 커널 코드를 커널 모드에서 실행한다.
## 3. 프로세스가 무엇인가요?
프로그램(program)은 컴퓨터가 실행할 수 있는 명령어들의 집합이다. 프로세스(process)는 컴퓨터에서 실행 중인 프로그램으로 각각의 프로세스는 독립된 메모리 공간을 할당 받는다. 명령어들과 데이터를 가진다.
## 4. 프로세스 주소공간에 대해 설명해 주세요.
- stack
함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 공간이다.
stack 영역의 값은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸한다.
- heap
런타임에 크기가 결정된다. 사용자에 의해 공간이 동적으로 할당되고 해제된다. 주로 참조형 데이터가 할당된다.
- data
전역 변수나 static 변수 등 프로그램이 사용할 수 있는 데이터를 저장하는 영역이다. 프로그램의 시작과 함께 할당되며 프로그램이 종료되면 소멸한다. 단, 초기화 되지 않은 변수가 존재한다면 BSS 영역에 저장된다.
- Text(Code) 영역
프로그램이 실행될 수 있도록 CPU가 해석 가능한 기계어 코드가 저장되어 있는 공간이다. 프로그램이 수정되면 안되므로 ReadOnly 상태로 저장되어있다.
## 5. 단기, 중기, 장기 스케쥴러에 대해 설명해 주세요.
**장기 스케줄러**는 작업 스케줄러라고도 부르며 어떤 프로세스를 ready queue에 삽입할지 결정하는 역할을 한다. 장기 디스크에서 하나의 프로그램을 가져와 커널에 등록하면 프로세스가 되는데 이때 디스크에서 어떤 프로그램을 가져와 커널에 등록할지 결정한다.

장기 스케줄러는 수십 초 내지 수 분 단위로 가끔 호출되기 때문에 상대적으로 속도가 느린 것이 허용된다. 또한 장기 스케줄러는 메모리에 동시에 올라가 있는 프로세스의 수를 조절하는 역할을 한다. 

현대의 시분할 시스템에서 사용되는 운영 체제는 일반적으로 장기 스케줄러를 두지 않는다. 

과거에는 적은 양의 메모리를 많은 프로세스에게 할당하면 프로세스 당 메모리 보유량이 적어져 장기 스케줄러가 이를 조절하는 역할을 했다. 현대의 운영체제에서는 프로세스가 시작되면 장기 스케줄러 없이 바로 그 프로세스에 메모리를 할당해 ready queue에 넣어준다.

**단기 스케줄러**는 CPU 스케줄러라고도 하며 ready 상태의 프로세스 중에서 어떤 프로세스를 다음 번에 실행 상태로 만들 것인지 결정한다. 일반적으로 스케줄러라 하면 단기 스케줄러를 의미한다. 단기 스케줄러는 ms 이하의 시간 단위로 매우 빈번하게 호출도므로 수행 속도가 빨라야 한다.

**중기 스케줄러**는 메모리에 적제된 프로세스 수를 관리한다. 너무 많은 프로세스에게 메모리를 할당해 시스템의 성능이 저하되는 경우 이를 해결하기 위해 메모리에 적재된 프로세스 수를 동적으로 조절하기 위해 추가된 스케줄러이다.

**디스패처(dispatcher)**는 선택된 프로세스에게 CPU를 할당하는 역할을 가진다.

**비선점 스케줄링**은 프로세스가 자신의 할 일을 끝내고 종료하는 경우 I/O 작업을 하러 가는 경우, 자발적으로 ready 상태로 돌아가는 경우에만  OS에서 개입을 하여 스케줄링을 한다.
따라서 신사적이고 협력적이며 느린 응답성을 가진다.

**선점 스케줄링**은 특정 이벤트가 발생되면 OS가 강제적으로 스케줄링을 실행시킨다. 적극적이며 강제적이고 빠른 응답성을 갖는다. 하지만 데이터 일관성 문제가 생긴다.

## 6. 컨텍스트 스위칭 시에는 어떤 일들이 일어나나요?
컨텍스트 스위칭(context switching)이란 CPU 코어에서 실행 중이던 프로세스 혹은 스레드가 다른 프로세스 스레드로 교체되는 것이다. 컨텍스트(context)는 프로세스 혹은 스레드의 CPU 혹은 메모리의 상태를 말한다. 컨텍스트 스위칭은 여러 프로세스와 스레드를 동시에 실행시키기 위해 필요하다. 주어진 time slice(quantum)을 다 사용했거나 I/O 작업을 해야하거나 다른 리소스를 기다려야할 때 컨텍스트 스위칭이 발생한다.
컨텍스트 스위칭은 각종 리소스를 관리, 감독하는 역할인 OS 커널(kernel)에 의해 실행된다.
- process context switching vs thread context switching
    - 공통점
        - 커널 모드에서 실행된다
        - CPU의 레지스터 상태를 교체한다.
    - 차이점
        - 프로세스 컨텍스트 스위칭은 가상(virtual) 메모리 주소 관련 처리를 추가로 실행한다. 
        - 따라서 프로세스 컨텍스트 스위칭보다 스레드 컨텍스트 스위칭이 빠르다. 왜냐하면 스레드는 같은 메모리 공간을 공유하기 때문에 메모리 주소 관련 처리는 하지 않고 CPU의 상태정도만 바꾼다. 
        - 서로 다른 프로세스의 스레드의 경우 공유하는 메모리 영역이 없기 때문에 캐시(cache) 오염(pollution)이 있다.

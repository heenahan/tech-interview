## 1. 시스템 콜이 무엇인지 설명해 주세요.
1. 프로그램 실행 중에 인터럽트(interrupt)가 발생하거나 시스템 콜(System call)을 호출하게 되면 유저모드에서 커널모드로 전환된다.
2. 커널모드로 전환되면 프로그램의 현재 CPU 상태를 저장한다. 그리고 커널이 인터럽트나 시스템 콜을 직접 처리한다. 즉, CPU에서 커널 코드가 실행된다.
3. 처리가 완료되면 중단됐던 프로그램의 CPU 상태를 복원한다.
4. 다시 통제권을 프로그램에게 반환하며 커널모드에서 유저모드로 전환된다.
5. 유저모드에서 프로그램이 이어서 실행된다.
커널은 운영체제의 핵심으로 시스템의 전반을 관리/감독하며 하드웨어와 관련된 작업을 직접 수행한다. 
시스템을 보호하기 위해 커널모드가 존재한다. 즉, 프로그램이 함부로 하드웨어를 점유해서 시스템을 붕괴시키지 못하도록 커널모드가 존재한다. 
**시스템 콜**은 프로그램이 OS 커널이 제공하는 서비스를 이용하고 싶을 때 시스템 콜을 통해 실행한다.
프로세스/스레드 관련, 파일 I/O 관련, 소켓 관련, 장치(device) 관련, 프로세스 통신 관련한 시스템 콜이 있디/ 
## 2. 인터럽트가 무엇인지 설명해 주세요.
**인터럽트**는 시스템에서 발생한 다양한 종류의 이벤트 혹은 그런 이벤트를 알리는 메커니즘이다.
전원에 문제가 생겼을 때, I/O 작업이 완료되었을 때, 시간이 다 됐을때, 0으로 나눴을 때, 잘못된 메모리 공간에 접근을 시도할 때 인터럽트가 발생한다.
인터럽트가 발생하면 CPU에서는 즉각적으로 인터럽트 처리를 위해 커널 코드를 커널 모드에서 실행한다.
## 3. 프로세스가 무엇인가요?
프로그램(program)은 컴퓨터가 실행할 수 있는 명령어들의 집합이다. 프로세스(process)는 컴퓨터에서 실행 중인 프로그램으로 각각의 프로세스는 독립된 메모리 공간을 할당 받는다. 명령어들과 데이터를 가진다.
## 4. 프로세스 주소공간에 대해 설명해 주세요.
- stack
함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 공간이다.
stack 영역의 값은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸한다.
- heap
런타임에 크기가 결정된다. 사용자에 의해 공간이 동적으로 할당되고 해제된다. 주로 참조형 데이터가 할당된다.
- data
전역 변수나 static 변수 등 프로그램이 사용할 수 있는 데이터를 저장하는 영역이다. 프로그램의 시작과 함께 할당되며 프로그램이 종료되면 소멸한다. 단, 초기화 되지 않은 변수가 존재한다면 BSS 영역에 저장된다.
- Text(Code) 영역
프로그램이 실행될 수 있도록 CPU가 해석 가능한 기계어 코드가 저장되어 있는 공간이다. 프로그램이 수정되면 안되므로 ReadOnly 상태로 저장되어있다.
## 5. 단기, 중기, 장기 스케쥴러에 대해 설명해 주세요.
**장기 스케줄러**는 작업 스케줄러라고도 부르며 어떤 프로세스를 ready queue에 삽입할지 결정하는 역할을 한다. 장기 디스크에서 하나의 프로그램을 가져와 커널에 등록하면 프로세스가 되는데 이때 디스크에서 어떤 프로그램을 가져와 커널에 등록할지 결정한다.

장기 스케줄러는 수십 초 내지 수 분 단위로 가끔 호출되기 때문에 상대적으로 속도가 느린 것이 허용된다. 또한 장기 스케줄러는 메모리에 동시에 올라가 있는 프로세스의 수를 조절하는 역할을 한다. 

현대의 시분할 시스템에서 사용되는 운영 체제는 일반적으로 장기 스케줄러를 두지 않는다. 

과거에는 적은 양의 메모리를 많은 프로세스에게 할당하면 프로세스 당 메모리 보유량이 적어져 장기 스케줄러가 이를 조절하는 역할을 했다. 현대의 운영체제에서는 프로세스가 시작되면 장기 스케줄러 없이 바로 그 프로세스에 메모리를 할당해 ready queue에 넣어준다.

**단기 스케줄러**는 CPU 스케줄러라고도 하며 ready 상태의 프로세스 중에서 어떤 프로세스를 다음 번에 실행 상태로 만들 것인지 결정한다. 일반적으로 스케줄러라 하면 단기 스케줄러를 의미한다. 단기 스케줄러는 ms 이하의 시간 단위로 매우 빈번하게 호출도므로 수행 속도가 빨라야 한다.

**중기 스케줄러**는 메모리에 적제된 프로세스 수를 관리한다. 너무 많은 프로세스에게 메모리를 할당해 시스템의 성능이 저하되는 경우 이를 해결하기 위해 메모리에 적재된 프로세스 수를 동적으로 조절하기 위해 추가된 스케줄러이다.
## 6. 컨텍스트 스위칭 시에는 어떤 일들이 일어나나요?
컨텍스트 스위칭(context switching)이란 CPU 코어에서 실행 중이던 프로세스 혹은 스레드가 다른 프로세스 스레드로 교체되는 것이다. 컨텍스트(context)는 프로세스 혹은 스레드의 CPU 혹은 메모리의 상태를 말한다. 컨텍스트 스위칭은 여러 프로세스와 스레드를 동시에 실행시키기 위해 필요하다. 주어진 time slice(quantum)을 다 사용했거나 I/O 작업을 해야하거나 다른 리소스를 기다려야할 때 컨텍스트 스위칭이 발생한다.
컨텍스트 스위칭은 각종 리소스를 관리, 감독하는 역할인 OS 커널(kernel)에 의해 실행된다.
- process context switching vs thread context switching
    - 공통점
        - 커널 모드에서 실행된다
        - CPU의 레지스터 상태를 교체한다.
    - 차이점
        - 프로세스 컨텍스트 스위칭은 가상(virtual) 메모리 주소 관련 처리를 추가로 실행한다. 
        - 따라서 프로세스 컨텍스트 스위칭보다 스레드 컨텍스트 스위칭이 빠르다. 왜냐하면 스레드는 같은 메모리 공간을 공유하기 때문에 메모리 주소 관련 처리는 하지 않고 CPU의 상태정도만 바꾼다. 
        - 서로 다른 프로세스의 스레드의 경우 공유하는 메모리 영역이 없기 때문에 캐시(cache) 오염(pollution)이 있다.

## 7. 프로세스 스케줄링 알고리즘에는 어떤 것들이 있나요?
**디스패처(dispatcher)**는 선택된 프로세스에게 CPU를 할당하는 역할을 가진다.

**비선점 스케줄링**은 프로세스가 자신의 할 일을 끝내고 종료하는 경우 I/O 작업을 하러 가는 경우, 자발적으로 ready 상태로 돌아가는 경우에만  OS에서 개입을 하여 스케줄링을 한다.
따라서 신사적이고 협력적이며 느린 응답성을 가진다.
**선점 스케줄링**은 특정 이벤트가 발생되면 OS가 강제적으로 스케줄링을 실행시킨다. 적극적이며 강제적이고 빠른 응답성을 갖는다. 하지만 데이터 일관성 문제가 생긴다.
- FCFS(First Come First Served)
    - 가장 먼저 요청한 프로세스에게 CPU를 할당해준다.
    - Convoy Effect가 발생하는데, 어떤 프로세스의 수행시간이 길면 대기시간이 늘어난다. 
- SJF(Shortest Job First)
    - 가장 짧은 수행 시간을 갖는 프로세스가 먼저 자원 할당을 받는다.
    - 수행 시간이 긴 프로세스는 짧은 프로세스에 밀려 Starvation이 발생한다.
- 우선순위 스케줄링
    - 우선 순위가 높은 프로세스부터 실행한다. 우선 순위가 같다면 FIFO로 동작한다.
    - 선점, 비선점 스케줄링 방식 모두 사용이 가능하다.
    - 비선점은 더 높은 우선순위의 프로세스가 도착하면 Ready Queue에 넣고 바로 다음에 실행되도록 한다.
    - 선점은 더 높은 우선순위의 프로세스가 도착하면 현재 실행 중인 프로세스의 CPU를 빼앗는다.
    - 우선 순위가 낮은 프로세스가 높은 프로세스에 의해 실행되고 있지 않은 상황이라면 그 프로세스의 우선순위를 높여 처리한다. 이를 에이징(Aging)이라 한다. 
- SRTF(Shortest Remaining Time First)
    - 선점 스케줄링으로 새로운 프로세스가 들어온 시점에서 현재까지 남은 실행시간이 가장 짧은 프로세스를 먼저 실행한다.
    - SJF처럼 실행 시간이 긴 프로세스가 영원히 CPU를 할당받을 수 없는 Starvation 문제가 발생한다.
- Round-Robin
    - 각 프로세스는 동일한 할당 시간(Time Quantum)을 가진다. CPU 할당을 받고 할당 시간이 지나면 Ready 상태로 돌아간다. 프로세스들이 작업을 완료할 때까지 계속 순회한다.
    - 응답 시간(Response Time)이 빨라진다. n개의 프로세스가 ready queue에 있고 할당 시간이 q인 경우 각 프로세스는 q 단위로 CPU 시간의 1/n을 얻는다. 즉, 어떤 프로세스도 (n - 1)q 이상 기다리지 않는다.
    - 설정한 time quantum이 너무 크다면 FCFS와 문제가 동일하다.
    - 반대로 너무 작다면 Context Switching으로 인한 Overhead가 증가한다.
- Multilevel Queue
    - 우선 순위마다 별도의 ReadyQueue를 형성하여 스케쥴링하는 방법
    - 프로세스 특성에 따라 우선순위가 부여되어 한 개의 큐에 영구적으로 할당되며 각 큐에는 그의 성격에 맞는 스케줄링 알고리즘을 별도로 적용할 수 있다. 
    - foreground 큐와 background 큐로 분할하여 전자는 interactive하고 CPU burst가 짧은 큐로서 우선순위가 높다. 그리고 후자는 Batch 등 긴 시간을 필요로 하는 작업이다.
## 8. 뮤텍스와 세마포어의 차이점은 무엇인가요?
- race condition (경쟁 조건)
여러 프로세스 혹은 스레드가 동시에 같은 데이터를 조작할 때 타이밍이나 접근 순서에 따라 결과가 달라질 수 있는 상황을 말한다.
- 동기화(synchronization)
여러 프로세스 혹은 스레드를 동시에 실행해도 공유 데이터의 일관성을 유지하는 것이다.
-critical section(임계 영역)
공유 데이터의 일관성을 보장하기 위해 하나의 프로세스 혹은 스레드만 진입해서 실행 가능한 영역이다.
- spin lock
락을 가질 때까지 반복하며 기다리는 동안 CPU를 낭비한다는 단점이 있다.
> 
cpu atomic 명령어
- 실행 중간에 간섭받거나 중단되지 않는다.
- 같은 메모리 영역에 대해서 동시에 실행되지 않는다.
> 
```c
volatile int lock = 0;

void critical() {
	while (test_and_set(&lock) == 1);
	// critical section
	lock = 0;
}

int test_and_set(int* lockPtr) { // CPU atomic 명령어
	int oldLock = *lockPtr;
	*lockPtr = 1;
	return oldLock;
}
```
- mutex
락을 가질 수 있을 때까지 휴식하여 불필요한 CPU 사이클 줄인다.
다만 뮤텍스보다 스핀락이 더 좋은 경우가 있다. 멀티 코어 환경이고 critical section에서의 작업이 컨텍스트 스위칭보다 더 빨리 끝난다면 스핀락이 뮤텍스보다 더 이점이다.뮤텍스는 큐에서 잠들어있다 깨는 과정에서 컨텍스트 스위칭 작업이 발생한다. 다만 싱글 코어에서 스핀락도 컨텍스트 스위칭이 필요하다.
- semaphore (세마포)
signal mechanism을 가진, 하나 이상의 프로세스 혹은 스레드가 critical section에 접근 가능하도록 하는 장치이다.
세마포는 순서를 정해줄 때 사용하며 wait와 signal이 같은 프로세스에서 실행되지 않을 수도 있다.

value로 1을 가지는 세마포어는 이진(binary) 세마포이고 1보다 큰 값을 가질 경우 counting 세마포이다.
순서를 정해줄 때 사용
그러면 뮤텍스와 이진(binary) 세마포는 같을까? 아니다. 뮤텍스는 락을 가진 자만 락을 해제할 수 있지만 세마포는 그렇지 않다. 
뮤텍스는 priority inheritance 속성을 가지지만 세마포는 그 속성이 없다. inheritance 속성이란 락을 가진 프로세스의 우선순위를 높여 critical section을 빠르게 빠져나오도록 한다. 우선순위가 낮은 프로세스가 락을 가질 경우 CPU에서 실행될 확률이 적기 때문에 critical section을 빠져나오지 못할 수도 있다. 결국 락이 필요한 우선순위 높은 프로세스가 락을 가진 우선순위 낮은 프로세스에 의존하는 문제가 발생하기 때문이다.

즉, 상호 배제만 필요할 경우 뮤텍스를 작업 간의 순서를 보장할 경우 세마포이다.
## 9. Deadlock 에 대해 설명해 주세요.
DeadLock(교착 상태)란 두 개 이상의 프로세스 혹은 스레드가 서로가 가진 리소스를 기다리는 상태이다.
데드락을 만드는 네 가지 조건은 다음과 같다.
1. Mutual exclusion
리소스(resource)를 공유해서 사용할 수 없다.
2. Hold and wait
프로세스가 이미 하나 이상의 리소스를 취득한(hold)한 상태에서 다른 프로세스가 사용하고 있는 리소스를 추가로 기다린다.(wait)
3. No preemption
리소스 반환(release)는 오직 그 리소스를 취득한 프로세스만 할 수 있다.
4. Circular wait
프로세스들이 순환(circular) 형태로 서로의 리소스를 기다린다.
이러한 데드락 해결하는 방법은 크게 3가지로 분류된다. 데드락이 발생하지 않도록 예방(prevention)하기, 데드락 발생 가능성을 인정하면서도 적절하게 회피(avoidance)하기, 데드락 발생을 허용하지만 데드락을 탐지(detection)하여, 데드락에서 회복하기.
- 데드락 예방(Prevention)
데드락의 발생 조건 4가지 중 하나라도 발생하지 않게 한다.
1. Mutual exclusion
한 번에 여러 프로세스가 공유 자원을 사용할 수 있게 한다. 그러나 이 방법은 추후 동기화 문제가 발생한다.
2. Hold and wait
사용할 리소스들을 모두 획득한 뒤에 시작한다. 리소스를 전혀 가지지 않은 상태에서만 리소스를 요청한다. 
다만 이 방법은 리소스 사용 효율이 떨어지며 인기 많은 자원을 확보하려 한다면 계속 waiting해야 한다. 이런 현상을 starvation이라고 한다.
3. no preemption
추가적인 리소스를 기다려야 한다면 이미 획득한 리소스를 다른 프로세스가 선점하도록 한다.
CPU의 컨텍스트 스위칭과 모니터와 비슷하다. 
4. circular wait
모든 리소스에 순서 체계를 부여해서 오름차순으로 리소스를 요청한다. 제일 많이 사용되는 방식이다.
- 데드락 회피(avoidance)
실행 환경에서 추가적인 정보를 활용해서 데드락이 발생할 것 같은 상황을 회피한다. 
**Banker algorithm**
리소스 요청을 허락해줬을 때 데드락이 발생할 가능성이 있으면 리소스를 할당해도 안전할 때까지 계속 요청을 거절하는 알고리즘이다.
- 데드락 감지와 복구
데드락을 허용하고 데드락이 발생하면 복구하는 전략이다. 복구 전략은 다음과 같다.
1. 프로세스를 종료한다.
2. 리소스의 일시적인 선점을 허용한다.
3. 데드락 무시하여 개발자에게 해결을 넘긴다.
## 10. 프로그램이 컴파일 되어, 실행되는 과정을 간략하게 설명해 주세요.
개발자가 작성한 소스 코드를 컴퓨터가 이해하는 언어인 기계어로 번역하여 컴퓨터에서 이해할 수 있는, 즉 실행 가능한 파일로 만드는 과정을 빌드(build)라고 한다.
C, C++, Go처럼 컴파일 언어의 빌드 과정을 살펴보면 다음과 같다.
- 전처리(preprocessing)
전처리기(preprocessor)에 의해 소스 코드에 포함된 매크로나 지시자 같은 것을 포함시켜준다. 즉, 소스코드의 중심(main)이 실행되기 전에 사전 준비를 한다.
- 컴파일(compilation)
소스 코드를 저수준 언어인 어셈블리어(Assembly Language)로 변역한다.
- 어셈블(assemble)
저수준 언어인 어셈블리어를 최종적으로 기계어로 번역해준다. CPU가 이해할 수 있는 언어로 번역된 파일을 보통 Object File이라고 부른다. 
- 링킹(linking)
기계어로 번역된 파일(Object File)들과 필요한 라이브러리들을 연결시켜주고 최종적으로 하나의 실행가능한 파일로 만들어준다.